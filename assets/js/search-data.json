{
  
    
        "post0": {
            "title": "Death by Mutation [WIP]",
            "content": "WARNING: This post is a work in progress. Please comeback later . Let start with a quiz. Try to guess the outputs of the following code block without running it. You can then check whether you&#39;re correct by clicking the Show Output button. . fs = [lambda: x for x in [1, 2, 3]] print(fs[0]()) print(fs[1]()) print(fs[2]()) . 3 3 3 . . For those of you who got it right, congratulations! For those of us who didn&#39;t, you might want to rerun the code in your own Python REPL to make sure I&#39;m not bluffing. After you&#39;re done with that, I recommend taking a moment to think about why it&#39;s behaving the way it does before reading on. . Before we start let&#39;s formalize what the intended vs actual behavior of the expression [lambda: x for x in [1, 2, 3]] is. We start with a list of values [1, 2, 3]. For each of these values we want a function that takes no argument and returns that value. The first function returns 1, the second function returns 2 and so on. At least that&#39;s what we would expect. Instead what we got is a list of functions that all return 3, the last value in the list. Why? . For those who, at this point, already has a guess for what&#39;s really happening, you can jump straight to the answer here. . Let&#39;s take a little detour and try another quiz. This one&#39;s pretty straightforward. Again, guess the outputs. . x = 1 def f(): return x print(f()) x = 2 print(f()) . 1 2 . . Since x is not defined inside f, whenever f is called, Python will look up the value of x in the environment where f is defined, which, in this case, is the global environment. Thus f() will always return the current value of the global variable x. . And that&#39;s exactly what&#39;s going on in our list comprehension example. List comprehensions in Python are most equivalent to for loops. [lambda: x for x in [1, 2, 3]] can be rewritten as: . fs = [] for x in [1, 2, 3]: def f(): return x fs.append(f) . Let&#39;s unroll the loop . fs = [] x = 1 def f(): return x fs.append(f) x = 2 def f(): return x fs.append(f) x = 3 def f(): return x fs.append(f) . Let&#39;s focus on the first function . x = 1 def f(): return x # fs.append(f) x = 2 # def f(): # return x # fs.append(f) x = 3 # def f(): # return x # fs.append(f) . Does it look familiar? It&#39;s because that&#39;s the exact same example in our 2nd quiz! . The answer . To recap, in our list comprehension example . fs = [lambda: x for x in [1, 2, 3]] print(fs[0]()) print(fs[1]()) print(fs[2]()) . 3 3 3 . x is not in the local scope of lambda: x but in the enclosing scope, where for x in [1, 2, 3] takes place. Thus x always takes the value of 3, the last value in the list, after the list comprehension finishes execution. . In other words, since x is not defined inside lambda: x, whenever fs[0] is called, Python will look up the value of x in the enclosing scope of lambda: x, the one where for x in [1, 2, 3] takes place. Here the last value x was assgined to is 3. Thus fs[0](), fs[1]() and fs[2]() will always return 3. . This can be better ilustrated using a generator instead of list comprehension . fs = (lambda: x for x in [1, 2, 3]) . which is equivalent to . def make_gen(xs): for x in xs: yield lambda: x fs = make_gen([1, 2, 3]) . f1 = next(fs) print(f&quot;{f1()=}&quot;) . f1()=1 . f2 = next(fs) print(f&quot;{f1()=}&quot;) print(f&quot;{f2()=}&quot;) . f1()=2 f2()=2 . f3 = next(fs) print(f&quot;{f1()=}&quot;) print(f&quot;{f2()=}&quot;) print(f&quot;{f3()=}&quot;) . f1()=3 f2()=3 f3()=3 . A caveat . The for loop is not 100% equivalent to our list comprehension example, however. The difference is that in the latter, x isn&#39;t in the global scope, i.e. you can&#39;t access it outside of the list comprehension . A more faithful reproduction would be . def make_funcs(): fs = [] for x in [1, 2, 3]: def f(): return x fs.append(f) return fs fs = make_funcs() . This, however, doesn&#39;t invalidate our explanation earlier. . The correct way . Now that we know what went wrong, how could we fix the code just a little so that it behaves the way we wanted? Hint: try converting the example into one that uses map. . The answer is function closure . def f(x): def g(): return x return g fs = [f(x) for x in [1, 2, 3]] print(fs[0]()) print(fs[1]()) print(fs[2]()) . 1 2 3 . which can be converted into a one-liner using lambda . fs = [(lambda x: lambda: x)(x) for x in [1, 2, 3]] . or partial function . from functools import partial fs = [partial(lambda x: x, x) for x in [1, 2, 3]] .",
            "url": "https://fastpages.kien.ai/death-by-mutation",
            "relUrl": "/death-by-mutation",
            "date": " • Nov 29, 2020"
        }
        
    
  

  
  

  
      ,"page1": {
          "title": "About Me",
          "content": "This website is powered by fastpages 1. . a blogging platform that natively supports Jupyter notebooks in addition to other formats. &#8617; . |",
          "url": "https://fastpages.kien.ai/about/",
          "relUrl": "/about/",
          "date": ""
      }
      
  

  

  
  

  

  
  

  

  
  

  
  

  
  

  
      ,"page10": {
          "title": "",
          "content": "Sitemap: {{ “sitemap.xml” | absolute_url }} | .",
          "url": "https://fastpages.kien.ai/robots.txt",
          "relUrl": "/robots.txt",
          "date": ""
      }
      
  

}